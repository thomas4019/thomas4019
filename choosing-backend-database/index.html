<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Choosing a backend database: SQL vs Document vs Columnar</title>
  
  <meta property="og:image" content="https://www.thomashansen.me/images/dbs_venn_diagram.png" />
  
  <style>
    body {
      background-color: #fbfbfb;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Helvetica Neue", Arial, sans-serif;
      max-width: 100ch;
      margin: 1.5rem auto;
      padding-left: 2rem;
      padding-right: 2rem;
    }
    pre.language-sql {
      padding: 10px;
    }
  </style>
</head>

<body>
  <section class="section">
    <div class="container">
      
<h1 class="title">
  Choosing a backend database: SQL vs Document vs Columnar
</h1>

<p>In the evolving landscape of databases, the lines distinguishing one type from another have blurred as features converge. How do you pick the right one for your needs? Here's a venn diagram showing which features are shared and which are unique.</p>
<p><img src="/images/dbs_venn_diagram.png" alt="Venn Diagram highlighting shared features among databases: All databases (ACID, Secondary Indexes, JSON), SQL &amp; Columnar (schemas), SQL &amp; Document (aggregate queries and unique indexes)." /></p>
<h2 id="guidelines">Guidelines</h2>
<p><strong>Join Queries</strong>: Opt for SQL databases if relational data handling is crucial.</p>
<p><strong>Deep Document Model</strong>: Choose a document database for intricate document structures and partial updates.</p>
<p><strong>Schema Flexibility</strong>: While the allure of schemalessness might steer you towards NoSQL, keep in mind that modern SQL databases offer JSON column support.</p>
<p><strong>Write-Heavy Workloads</strong>: If your primary operation is writing and you require scalability, a columnar DB might be your best bet.</p>
<p>Whether or not one uses a NoSQL database, many of the principles of NoSQL/document databases are helpful when designing an application. For example, ask yourself, how could I design a system where I wouldnâ€™t need to use joins.</p>
<h2 id="database-notes">Database notes</h2>
<p><strong>MongoDB:</strong> Nice for prototyping since it's so easy to use without schemas. It's very easy to end up with inconsistent data over time since the DB doesn't enforce much and people often don't do proper data migrations. Large nested document structures is great for data locality.</p>
<p><strong>PostgreSQL and MySQL:</strong> Over time, these have become more similar e.g. both allow adding columns without locking, json columns, common table expressions and unicode. Note: While there is a standard for SQL, no database adheres to it perfectly. As a result, your application may inherit quirks specific to the database you select.</p>
<p><strong>DynamoDB:</strong> This is an Amazon proprietary DB. It's a cost effective option for write heavy workloads that you want to able to scale indefinitely.</p>

<hr>
By <a href="https://github.com/thomas4019">Thomas Hansen</a>, published on 2023-10-15

    </div>
  </section>
</body>

</html>